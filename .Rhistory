View(results)
TennisBallSimulation(pos_player, height, v0, w_ball, spin = 1, theta, alpha)
pos_player <- population_inputs[1:2,5]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,5]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
spin = 1
pos_player <- population_inputs[1:2,5]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,5]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
sols <- ode(y = state, times = times, func = EquationsOfMotion, parms = parameters) # Solve the equations of motion
# Determine whether the ball makes it over the net
if(pos_player[1] < 0){
distance_to_net <- abs(pos_player[1]/cos(alpha * pi / 180)) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}else{
distance_to_net <- pos_player[1]/cos(alpha * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], -distance_to_net)$y # Time at which the ball reaches the net
}
View(sols)
pos_player <- population_inputs[1:2,4]
distance_to_net <- pos_player[1]/cos(alpha * pi / 180) # Distance from the player's position to the net
spin = 1
pos_player <- population_inputs[1:2,4]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,5]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
sols <- ode(y = state, times = times, func = EquationsOfMotion, parms = parameters) # Solve the equations of motion
View(sols)
# Determine whether the ball makes it over the net
if(pos_player[1] < 0){
distance_to_net <- pos_player[1]/cos(alpha * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}else{
distance_to_net <- pos_player[1]/cos(alpha * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], -distance_to_net)$y # Time at which the ball reaches the net
}
# Determine whether the ball makes it over the net
if(pos_player[1] < 0){
distance_to_net <- abs(pos_player[1])/cos(alpha * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}else{
distance_to_net <- pos_player[1]/cos(alpha * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], -distance_to_net)$y # Time at which the ball reaches the net
}
spin = 1
pos_player <- population_inputs[1:2,4]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,5]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
sols <- ode(y = state, times = times, func = EquationsOfMotion, parms = parameters) # Solve the equations of motion
# Determine whether the ball makes it over the net
if(pos_player[1] < 0){
distance_to_net <- abs(pos_player[1])/cos(abs(alpha) * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}else{
distance_to_net <- pos_player[1]/cos(abs(alpha) * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}
pos_player <- population_inputs[1:2,5]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,5]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
sols <- ode(y = state, times = times, func = EquationsOfMotion, parms = parameters) # Solve the equations of motion
# Determine whether the ball makes it over the net
if(pos_player[1] < 0){
distance_to_net <- abs(pos_player[1])/cos(abs(alpha) * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}else{
distance_to_net <- pos_player[1]/cos(abs(alpha) * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
}
rm(list = ls()) # Clear global environment
###############################
### DEFINE GLOBAL VARIABLES ###
###############################
max_v0 <- 60
max_theta <- -10
max_alpha <- 10
max_w_ball <- 500
############################
### SETUP NEURAL NETWORK ###
############################
source("NeuralNetworkServe.R")
#############################################
### SPAWN PLAYER AND POPULATION VARIABLES ###
#############################################
population_inputs <- matrix(rep(NA, nInputs * population), nrow = nInputs, ncol = population)
population_dna <- list()
population_outputs <- matrix(rep(NA, nOutputs * population), nrow = nOutputs, ncol= population)
pos_player <- c()
serve_left <- FALSE
serve_right <- FALSE
serve_top <- FALSE
serve_bottom <- FALSE
##############################
### SET DNA OF EACH PLAYER ###
##############################
source("DNAServe.R")
for(i in 1:population){
population_dna[[i]] <- CreateInitialDNA(neurons = empty_neurons)
}
####################################################################
### CHOOSE SERVING SIDE AND SET THE PLAYER'S POSITION AND HEIGHT ###
####################################################################
for(i in 1:population){
height_player <- runif(1, 1.7, 1.98)
# Set the serving side (field)
if(runif(1) > 0.5){
serve_top <- TRUE
serve_bottom <- FALSE
}else{
serve_top <- FALSE
serve_bottom <- TRUE
}
# Set the serving side (baseline)
if(runif(1) > 0.5){
serve_left <- TRUE
serve_right <- FALSE
}else{
serve_left <- FALSE
serve_right <- TRUE
}
# Set the position
if(serve_left){
if(serve_top){
pos_player <- c(12, runif(1, 0, 2), height_player)
}else{
pos_player <- c(-12, runif(1, 0, 2), height_player)
}
}else{
if(serve_top){
pos_player <- c(12, runif(1, -2, 0), height_player)
}else{
pos_player <- c(-12, runif(1, -2, 0), height_player)
}
}
population_inputs[,i] <- pos_player
}
##############################
### FEEDFORWARD AND OUTPUTS###
##############################
output_scalars <- c(max_v0, max_theta, max_alpha, max_w_ball)
for(i in 1:population){
population_outputs[,i] <- FeedForward(population_inputs[,i], population_dna[[i]])*output_scalars
}
#######################
### BALL TRAJECTORY ###
#######################
source("Equations of Motion.R")
results <- list()
for(i in 1:population){
pos_player <- population_inputs[1:2,i]
height <- population_inputs[3,i]
v0 <- population_outputs[1,i]
theta <- population_outputs[2,i]
alpha <- population_outputs[3,i]
w_ball <- population_outputs[4,i]
results[[i]] <- TennisBallSimulation(pos_player, height, v0, w_ball, spin = 1, theta, alpha)
}
View(results)
spin = 1
pos_player <- population_inputs[1:2,0]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,0]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
sols <- ode(y = state, times = times, func = EquationsOfMotion, parms = parameters) # Solve the equations of motion
View(sols)
# Determine whether the ball makes it over the net
distance_to_net <- abs(pos_player[1])/cos(abs(alpha) * pi / 180) # Distance from the player's position to the net
pos_player <- population_inputs[1:2,1]
height <- population_inputs[3,5]
v0 <- population_outputs[1,5]
theta <- population_outputs[2,5]
alpha <- population_outputs[3,1]
w_ball <- population_outputs[4,5]
v_spin <- R * w_ball
v0_x <- v0 * cos(theta * pi / 180)
v0_y <- v0 * sin(theta * pi / 180)
# Set the initial state of the system
parameters <- c(v0 = v0, k = k, C_d = C_d(v0, v_spin), C_l = C_l(v0, v_spin), spin = spin, g = g) # Set parameters
state <- c(X1 = 0, X2 = v0_x, Y1 = height, Y2 = v0_y) # Define the state the system is in
times <- seq(0, 2, time_step) # Set time range
sols <- ode(y = state, times = times, func = EquationsOfMotion, parms = parameters) # Solve the equations of motion
# Determine whether the ball makes it over the net
distance_to_net <- abs(pos_player[1])/cos(abs(alpha) * pi / 180) # Distance from the player's position to the net
t_net <- approx(sols[,2], sols[,1], distance_to_net)$y # Time at which the ball reaches the net
View(sols)
rm(list = ls()) # Clear global environment
###############################
### DEFINE GLOBAL VARIABLES ###
###############################
max_v0 <- 60
max_theta <- -10
max_alpha <- 10
max_w_ball <- 500
############################
### SETUP NEURAL NETWORK ###
############################
source("NeuralNetworkServe.R")
#############################################
### SPAWN PLAYER AND POPULATION VARIABLES ###
#############################################
population_inputs <- matrix(rep(NA, nInputs * population), nrow = nInputs, ncol = population)
population_dna <- list()
population_outputs <- matrix(rep(NA, nOutputs * population), nrow = nOutputs, ncol= population)
pos_player <- c()
serve_left <- FALSE
serve_right <- FALSE
serve_top <- FALSE
serve_bottom <- FALSE
##############################
### SET DNA OF EACH PLAYER ###
##############################
source("DNAServe.R")
for(i in 1:population){
population_dna[[i]] <- CreateInitialDNA(neurons = empty_neurons)
}
####################################################################
### CHOOSE SERVING SIDE AND SET THE PLAYER'S POSITION AND HEIGHT ###
####################################################################
for(i in 1:population){
height_player <- runif(1, 1.7, 1.98)
# Set the serving side (field)
if(runif(1) > 0.5){
serve_top <- TRUE
serve_bottom <- FALSE
}else{
serve_top <- FALSE
serve_bottom <- TRUE
}
# Set the serving side (baseline)
if(runif(1) > 0.5){
serve_left <- TRUE
serve_right <- FALSE
}else{
serve_left <- FALSE
serve_right <- TRUE
}
# Set the position
if(serve_left){
if(serve_top){
pos_player <- c(12, runif(1, 0, 2), height_player)
}else{
pos_player <- c(-12, runif(1, 0, 2), height_player)
}
}else{
if(serve_top){
pos_player <- c(12, runif(1, -2, 0), height_player)
}else{
pos_player <- c(-12, runif(1, -2, 0), height_player)
}
}
population_inputs[,i] <- pos_player
}
##############################
### FEEDFORWARD AND OUTPUTS###
##############################
output_scalars <- c(max_v0, max_theta, max_alpha, max_w_ball)
for(i in 1:population){
population_outputs[,i] <- FeedForward(population_inputs[,i], population_dna[[i]])*output_scalars
}
#######################
### BALL TRAJECTORY ###
#######################
source("Equations of Motion.R")
results <- list()
for(i in 1:population){
pos_player <- population_inputs[1:2,i]
height <- population_inputs[3,i]
v0 <- population_outputs[1,i]
theta <- population_outputs[2,i]
alpha <- population_outputs[3,i]
w_ball <- population_outputs[4,i]
results[[i]] <- TennisBallSimulation(pos_player, height, v0, w_ball, spin = 1, theta, alpha)
}
View(results)
ball_reach_net <- "ball didn't reach the net"
rm(list = ls()) # Clear global environment
###############################
### DEFINE GLOBAL VARIABLES ###
###############################
max_v0 <- 60
max_theta <- -10
max_alpha <- 10
max_w_ball <- 500
############################
### SETUP NEURAL NETWORK ###
############################
source("NeuralNetworkServe.R")
#############################################
### SPAWN PLAYER AND POPULATION VARIABLES ###
#############################################
population_inputs <- matrix(rep(NA, nInputs * population), nrow = nInputs, ncol = population)
population_dna <- list()
population_outputs <- matrix(rep(NA, nOutputs * population), nrow = nOutputs, ncol= population)
pos_player <- c()
serve_left <- FALSE
serve_right <- FALSE
serve_top <- FALSE
serve_bottom <- FALSE
##############################
### SET DNA OF EACH PLAYER ###
##############################
source("DNAServe.R")
for(i in 1:population){
population_dna[[i]] <- CreateInitialDNA(neurons = empty_neurons)
}
####################################################################
### CHOOSE SERVING SIDE AND SET THE PLAYER'S POSITION AND HEIGHT ###
####################################################################
for(i in 1:population){
height_player <- runif(1, 1.7, 1.98)
# Set the serving side (field)
if(runif(1) > 0.5){
serve_top <- TRUE
serve_bottom <- FALSE
}else{
serve_top <- FALSE
serve_bottom <- TRUE
}
# Set the serving side (baseline)
if(runif(1) > 0.5){
serve_left <- TRUE
serve_right <- FALSE
}else{
serve_left <- FALSE
serve_right <- TRUE
}
# Set the position
if(serve_left){
if(serve_top){
pos_player <- c(12, runif(1, 0, 2), height_player)
}else{
pos_player <- c(-12, runif(1, 0, 2), height_player)
}
}else{
if(serve_top){
pos_player <- c(12, runif(1, -2, 0), height_player)
}else{
pos_player <- c(-12, runif(1, -2, 0), height_player)
}
}
population_inputs[,i] <- pos_player
}
##############################
### FEEDFORWARD AND OUTPUTS###
##############################
output_scalars <- c(max_v0, max_theta, max_alpha, max_w_ball)
for(i in 1:population){
population_outputs[,i] <- FeedForward(population_inputs[,i], population_dna[[i]])*output_scalars
}
#######################
### BALL TRAJECTORY ###
#######################
source("Equations of Motion.R")
results <- list()
for(i in 1:population){
pos_player <- population_inputs[1:2,i]
height <- population_inputs[3,i]
v0 <- population_outputs[1,i]
theta <- population_outputs[2,i]
alpha <- population_outputs[3,i]
w_ball <- population_outputs[4,i]
results[[i]] <- TennisBallSimulation(pos_player, height, v0, w_ball, spin = 1, theta, alpha)
}
View(results)
View(results)
rm(list = ls()) # Clear global environment
###############################
### DEFINE GLOBAL VARIABLES ###
###############################
max_v0 <- 60
max_theta <- -10
max_alpha <- 10
max_w_ball <- 500
############################
### SETUP NEURAL NETWORK ###
############################
source("NeuralNetworkServe.R")
#############################################
### SPAWN PLAYER AND POPULATION VARIABLES ###
#############################################
population_inputs <- matrix(rep(NA, nInputs * population), nrow = nInputs, ncol = population)
population_dna <- list()
population_outputs <- matrix(rep(NA, nOutputs * population), nrow = nOutputs, ncol= population)
pos_player <- c()
serve_left <- FALSE
serve_right <- FALSE
serve_top <- FALSE
serve_bottom <- FALSE
##############################
### SET DNA OF EACH PLAYER ###
##############################
source("DNAServe.R")
for(i in 1:population){
population_dna[[i]] <- CreateInitialDNA(neurons = empty_neurons)
}
####################################################################
### CHOOSE SERVING SIDE AND SET THE PLAYER'S POSITION AND HEIGHT ###
####################################################################
for(i in 1:population){
height_player <- runif(1, 1.7, 1.98)
# Set the serving side (field)
if(runif(1) > 0.5){
serve_top <- TRUE
serve_bottom <- FALSE
}else{
serve_top <- FALSE
serve_bottom <- TRUE
}
# Set the serving side (baseline)
if(runif(1) > 0.5){
serve_left <- TRUE
serve_right <- FALSE
}else{
serve_left <- FALSE
serve_right <- TRUE
}
# Set the position
if(serve_left){
if(serve_top){
pos_player <- c(12, runif(1, 0, 2), height_player)
}else{
pos_player <- c(-12, runif(1, 0, 2), height_player)
}
}else{
if(serve_top){
pos_player <- c(12, runif(1, -2, 0), height_player)
}else{
pos_player <- c(-12, runif(1, -2, 0), height_player)
}
}
population_inputs[,i] <- pos_player
}
##############################
### FEEDFORWARD AND OUTPUTS###
##############################
output_scalars <- c(max_v0, max_theta, max_alpha, max_w_ball)
for(i in 1:population){
population_outputs[,i] <- FeedForward(population_inputs[,i], population_dna[[i]])*output_scalars
}
#######################
### BALL TRAJECTORY ###
#######################
source("Equations of Motion.R")
results <- list()
for(i in 1:population){
pos_player <- population_inputs[1:2,i]
height <- population_inputs[3,i]
v0 <- population_outputs[1,i]
theta <- population_outputs[2,i]
alpha <- population_outputs[3,i]
w_ball <- population_outputs[4,i]
results[[i]] <- TennisBallSimulation(pos_player, height, v0, w_ball, spin = 1, theta, alpha)
}
View(results)
